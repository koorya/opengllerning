
#include "movement_program.h"

#include <cmath>


#define EPSILON 0.01


struct MovementStep sp_programs[17][8];//17 программ по 8 шагов каждая, неиспользуемые шаги в конце с осью none

void fillUpSPProgramsArray(){
	float raw_array[] = {
							1,	2,	-180,	200,	200,	200,	165,	1,	5,	-90,	500,	200,	200,	50,	1,	3,	1509,	2000,	2000,	2000,	1400,	1,	1,	170,	2000,	2000,	2000,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	93,	200,	200,	200,	65,	1,	1,	2866.26,	2000,	2000,	2000,	2700,	1,	4,	87,	500,	200,	200,	80,	1,	5,	-90,	500,	200,	200,	70,	1,	3,	1509,	2000,	2000,	2000,	1000,	1,	7,	-617,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	-93,	200,	200,	200,	65,	1,	1,	2866.26,	2000,	2000,	2000,	2700,	1,	4,	-87,	500,	200,	200,	80,	1,	5,	-90,	500,	200,	200,	70,	1,	3,	1509,	2000,	2000,	2000,	1000,	1,	7,	-617,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	87,	200,	200,	200,	65,	1,	1,	2866.26,	2000,	2000,	2000,	2700,	1,	4,	-87,	500,	200,	200,	80,	1,	5,	-90,	500,	200,	200,	70,	1,	3,	1509,	2000,	2000,	2000,	1000,	1,	7,	617,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	-87,	200,	200,	200,	65,	1,	1,	2866.26,	2000,	2000,	2000,	2700,	1,	4,	87,	500,	200,	200,	80,	1,	5,	-90,	500,	200,	200,	70,	1,	3,	1509,	2000,	2000,	2000,	1000,	1,	7,	617,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	101.59,	200,	200,	200,	65,	1,	1,	2289.34,	2000,	2000,	2000,	2000,	1,	5,	-153,	500,	200,	200,	100,	1,	4,	78.41,	500,	200,	200,	50,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	7,	-220,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	-105.77,	200,	200,	200,	65,	1,	1,	2341.55,	2000,	2000,	2000,	2000,	1,	5,	-27,	500,	200,	200,	20,	1,	4,	-74.23,	500,	200,	200,	50,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	7,	0,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	-196.67,	200,	200,	200,	180,	1,	5,	-27,	500,	200,	200,	25,	1,	4,	16.67,	500,	200,	200,	15,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	7,	1300,	500,	200,	200,	700,	1,	1,	1562.52,	2000,	2000,	2000,	10,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	-142,	200,	200,	200,	100,	1,	5,	-153,	500,	200,	200,	100,	1,	4,	-38,	500,	200,	200,	30,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	1,	387.25,	2000,	2000,	2000,	10,	1,	7,	0,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	74.23,	200,	200,	200,	65,	1,	1,	2341.55,	2000,	2000,	2000,	2000,	1,	5,	-27,	500,	200,	200,	20,	1,	4,	-74.23,	500,	200,	200,	50,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	7,	0,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	-74.23,	200,	200,	200,	65,	1,	1,	2341.55,	2000,	2000,	2000,	2000,	1,	5,	-153,	500,	200,	200,	100,	1,	4,	74.23,	500,	200,	200,	50,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	7,	0,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	90,	200,	200,	200,	65,	1,	5,	-90,	500,	200,	200,	50,	1,	3,	1509,	2000,	2000,	2000,	1400,	1,	1,	170,	2000,	2000,	2000,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	-90,	200,	200,	200,	65,	1,	5,	-90,	500,	200,	200,	50,	1,	3,	1509,	2000,	2000,	2000,	1400,	1,	1,	170,	2000,	2000,	2000,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	99.22,	200,	200,	200,	70,	1,	5,	-153,	500,	200,	200,	100,	1,	4,	-9.22,	500,	200,	200,	14,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	1,	180.6,	2000,	2000,	2000,	10,	1,	7,	-500,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	-128,	200,	200,	200,	100,	1,	5,	-27,	500,	200,	200,	20,	1,	4,	38,	500,	200,	200,	30,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	1,	387.25,	2000,	2000,	2000,	10,	1,	7,	0,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	52,	200,	200,	200,	40,	1,	5,	-27,	500,	200,	200,	20,	1,	4,	38,	500,	200,	200,	30,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	1,	387.25,	2000,	2000,	2000,	10,	1,	7,	0,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,
							1,	2,	-52,	200,	200,	200,	50,	1,	5,	-153,	500,	200,	200,	100,	1,	4,	-38,	500,	200,	200,	30,	1,	3,	58.17,	2000,	2000,	2000,	100,	1,	1,	387.25,	2000,	2000,	2000,	10,	1,	7,	0,	500,	200,	200,	0.0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0
						};
	for (int i = 0; i < 17; i++){
		for(int j = 0; j < 8; j++){
			sp_programs[i][j].axis = static_cast <enum AxisName> (std::round(raw_array[i*8*7 + j*7 + 1]));
			sp_programs[i][j].POS = raw_array[i*8*7 + j*7 + 2];
			sp_programs[i][j].Vel = raw_array[i*8*7 + j*7 + 3];
			sp_programs[i][j].Acc = raw_array[i*8*7 + j*7 + 4];
			sp_programs[i][j].Dec = raw_array[i*8*7 + j*7 + 5];
			sp_programs[i][j].Next = raw_array[i*8*7 + j*7 + 6];
		}
	}
}

#define AXIS_CNT 15
struct AxisDriver axes[AXIS_CNT];

int cur_program;
int cur_step;
float last_time;
void resetDrivers(int prg_id){
	cur_program = prg_id;
	cur_step = 0;
	for(int i = 0; i < AXIS_CNT; i++){
		axes[i].activate = false;
		axes[i].Acc = 0.0;
		axes[i].cur_pos = 0.0;
		axes[i].set_point = 0.0;
		axes[i].Vel = 0.0;
		axes[i].Acc = 0.0;
		axes[i].Dec = 0.0;
	}
}

float getAxisValue(AxisName id){
	return axes[id].cur_pos;
}

int driverSM(float time){
	float dt = last_time - time;
	last_time = time;
	int last_step = 0;
	int all_axis_complete = 1;

	struct MovementStep cstep = sp_programs[cur_program][cur_step];

	if(axes[cstep.axis].activate == false){//перешли на следующий шаг
		if(cstep.axis == AxisName::none)
			last_step = 1;
		axes[cstep.axis].activate = true;
		axes[cstep.axis].set_point = cstep.POS;
		axes[cstep.axis].Vel = cstep.Vel * ((cstep.POS>0)?1:-1);
		axes[cstep.axis].Acc = cstep.Acc;
		axes[cstep.axis].Dec = cstep.Dec;
		if(cur_step == 0){//означает, что это первый цикл
			dt = 0.0;
		}
	}
	if(std::fabs(axes[cstep.axis].cur_pos) >= cstep.Next){
		if(cstep.Next > 0.0){//это означает, чно порог включения следующего шага достигнут
			cur_step ++;
		}else if(std::fabs(axes[cstep.axis].cur_pos - axes[cstep.axis].set_point) < EPSILON){//это означает, чно нужно дождаться окончания этого шага
			cur_step ++;
		}
		if(cur_step >= 8){
			cur_step = 7;
			last_step = 1;
		}
	}

	for(int i = 0; i < AXIS_CNT; i++){
		if(axes[i].activate == false)
			continue;
		float remaining_dist = axes[i].cur_pos - axes[i].set_point;
		float dx = axes[i].Vel*dt;
		if( std::fabs(remaining_dist + dx) < std::fabs(remaining_dist) ){ // если следующий шаг нас приближает к конечной точке, то добавляем шаг
			axes[i].cur_pos += dx;
			all_axis_complete = 0;
		}else{	
				// если следующий шаг нас удаляет от конечной точки (т.е. пропустили изза большого шага дискретизации), 
				// то выключаем скорость и устанавливаем позицию в конечную точку
			axes[i].Vel = 0.0;
			axes[i].cur_pos = axes[i].set_point;
		}
	}

	return last_step & all_axis_complete;
}
